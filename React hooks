 React Hooks are one of the most powerful and popular features in React â€” they let you use state and lifecycle features inside functional components (instead of writing class components).
ğŸ” What Are React Hooks?
Hooks are functions that let you â€œhook intoâ€ React features like state, side effects, refs, and more.

They were introduced in React 16.8 and allow functional components to do everything by class components can do â€” but cleaner.
ğŸ£ Most Common React Hooks (with examples)
1. useState() â€“ To Store & Update State

import { useState } from "react";
function Counter() {
  const [count, setCount] = useState(0); // Initial state is 0

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={() => setCount(count + 1)}>Add</button>
    </div>
  );
}
OR
import React,{useState} from react;
function Counter(){
  const [count, setCount] = useState(0);
  function increment(){
    setCount(count+1);
  }
  return (
    <button onClick = {increment}>count:{count}</button>
  )
}
export default Counter;
----------------------------------------------------------------------------------------------------------------------------------------------------------
2.useEffect((),return,[])

useEffect is one of the most important and powerful hooks in React â€” it's used to handle side effects in your components.
ğŸ£ What is useEffect?
ğŸ‘‰ It lets you run code after the component renders.
This includes:
ğŸ›  Fetching data (API calls)
ğŸ§¹ Setting up or cleaning up things (like event listeners, timers)
ğŸ’¾ Interacting with the DOM (like focusing an input);

useEffect(() => {
  // Your side-effect code here

  return () => {
    // (optional) Cleanup code goes here
  };
}, [dependencies]);


âœ… useEffect Full Structure:
js
useEffect(() => {
  // ğŸŸ¢ 1. Main effect logic (runs after render)

  return () => {
    // ğŸ”´ 2. Optional cleanup logic (runs before unmount or before next effect)
  };
}, [/* ğŸŸ¡ 3. Dependency array */]);
ğŸ’¡ Each part explained:
ğŸŸ¢ 1. Callback Function (Main Effect)
This is where you put the side effect code:
API calls
Timers
DOM changes
Subscriptions

ğŸ”´ 2. Return Function (Cleanup - Optional)
This is called:
Just before the component unmounts (disappears)
Or before re-running the effect (if dependencies changed)
Used to:
Clear timers
Remove event listeners
Cancel network requests

ğŸŸ¡ 3. Dependency Array
Tells React when to re-run the effect
Common options:
[] â†’ run once
[count] â†’ run when count changes
no array â†’ run on every render (usually not recommended)

âœ… Simple Example: Logging on count change
js
useEffect(() => {
  console.log("Count changed!");

  return () => {
    console.log("Cleaning up...");
  };
}, [count]);


ğŸ”„ When does useEffect run?
It depends on the dependencies array (the second argument):

1ï¸âƒ£ No second argument â†’ runs after every render
jsx
Copy
Edit
useEffect(() => {
  console.log("I run after every render");
});
2ï¸âƒ£ Empty array [] â†’ runs only once (like componentDidMount)
jsx
Copy
Edit
useEffect(() => {
  console.log("I run only once when the component mounts");
}, []);
3ï¸âƒ£ With dependencies â†’ runs only when those values change
jsx
Copy
Edit
useEffect(() => {
  console.log("Runs only when `count` changes");
}, [count]);
âš™ï¸ Common Use Cases
ğŸ”¹ 1. Fetch data on component mount
jsx
Copy
Edit
useEffect(() => {
  fetch("https://api.example.com/data")
    .then((res) => res.json())
    .then((data) => console.log(data));
}, []); // only once
ğŸ”¹ 2. Set up a timer or interval
jsx
Copy
Edit
useEffect(() => {
  const timer = setInterval(() => {
    console.log("Tick");
  }, 1000);

  return () => clearInterval(timer); // cleanup on unmount
}, []);
ğŸ”¹ 3. Cleanup an event listener
jsx
Copy
Edit
useEffect(() => {
  const handleClick = () => alert("Clicked!");
  window.addEventListener("click", handleClick);

  return () => {
    window.removeEventListener("click", handleClick); // cleanup
  };
}, []);
ğŸ§¼ Why is the cleanup function important?
Without it, you could cause:

Memory leaks

Multiple intervals stacking

Extra event listeners

Think of it like turning off a light when you leave a room.

ğŸ“¦ Full Example: Counter with document title
jsx
Copy
Edit
import { useState, useEffect } from "react";

function Counter() {
  const [count, setCount] = useState(0);

  useEffect(() => {
    // Side effect: set document title
    document.title = `Count is ${count}`;
  }, [count]); // Only runs when `count` changes

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={() => setCount(count + 1)}>Increment</button>
    </div>
  );
}
ğŸ§  Summary

Trigger	                 Dependency Array                     	When It Runs
Every render	                 (none)                      	After every render
On mount only	                   []	                  Just once after first render
On value change          	[var1, var2]	             Only when var1 or var2 changes
With cleanup	          Return a function	           Runs during unmount or re-render
********************************************************************************************************************************
 When we talk about â€œmaintaining side effectsâ€ in React â€” especially in the context of useEffect â€” we mean:

ğŸ’¡ What is a "Side Effect"?
In React, a side effect is anything that happens outside the componentâ€™s rendering logic.

Examples of side effects:
âœ… Fetching data from an API

âœ… Setting a timer (setTimeout, setInterval)

âœ… Manually changing the DOM (like focusing an input)

âœ… Subscribing to a WebSocket or event

âœ… Logging to the console

âœ… Updating the document.title

âœ… Working with localStorage or cookies

âœ… Why Do We Need to Maintain Side Effects?
Because side effects live outside Reactâ€™s core rendering process, they need special handling:

To start them at the right time (e.g., after render)

To stop/clean them when they're no longer needed (to avoid bugs or memory leaks)

Thatâ€™s where useEffect comes in.


